This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-02T21:04:03.218Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/App.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/config.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/InteractionManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/main.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/ModelManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/PopupManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/postprocessing/CustomOutlinePass.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/postprocessing/FindSurfaces.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/UIManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/World.js

================================================================
Repository Files
================================================================

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/App.js
================
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import TWEEN from 'three/examples/jsm/libs/tween.module.js';

// Imports for post-processing
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { CustomOutlinePass } from './postprocessing/CustomOutlinePass.js';

import { World } from './World.js';
import { ModelManager } from './ModelManager.js';
import { UIManager } from './UIManager.js';
import { InteractionManager } from './InteractionManager.js';
import { PopupManager } from './PopupManager.js';
import { CAMERA_CONFIG, CONTROLS_CONFIG } from './config.js';

export class App {
    constructor(canvas) {
        this.canvas = canvas;

        // Core Three.js components
        this.scene = new THREE.Scene();
        this.camera = this._createCamera();
        
        // Create the renderer first, then set its initial size.
        this.renderer = this._createRenderer(); 
        this._updateRendererSize();

        this.controls = this._createControls();

        // App Composer and Post-processing
        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        this.outlinePass = new CustomOutlinePass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            this.scene,
            this.camera
        );
        // configure outline pass to only see meshes marked on layer 1
        this.outlinePass.outlineLayer = 1; // custom property used by CustomOutlinePass to filter
        this.composer.addPass(this.outlinePass);

        // App components
        this.world = new World(this.scene);
        this.modelManager = new ModelManager(this.scene);
        this.uiManager = new UIManager();
        this.interactionManager = new InteractionManager(this.camera, this.scene, this.canvas);
        this.popupManager = new PopupManager(this.camera, this.controls, this.uiManager);

        // Bind 'this' to methods
        this.animate = this.animate.bind(this);
        this._onResize = this._onResize.bind(this);
    }

    async init() {
        this.world.setup();

        this.interactionManager.addEventListener('pinClick', (e) => {
            this.popupManager.show(e.pin, e.event);
        });
        this.interactionManager.init();

        this.modelManager.onPinsLoaded = (pins) => {
        this.interactionManager._createPins(pins);
        };
      
        try {
            await this.modelManager.loadAll();
            this.uiManager.createFloorUI(this.modelManager);
        } catch (error) {
            console.error('failed to load models:', error);
        }

        window.addEventListener('resize', this._onResize);
        this.animate();
    }

    _createCamera() {
        const camera = new THREE.PerspectiveCamera(
            CAMERA_CONFIG.fov,
            window.innerWidth / window.innerHeight,
            CAMERA_CONFIG.near,
            CAMERA_CONFIG.far
        );
        camera.position.set(CAMERA_CONFIG.position.x, CAMERA_CONFIG.position.y, CAMERA_CONFIG.position.z);
        this.scene.add(camera);
        return camera;
    }

    _createRenderer() {
        const renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        renderer.setClearColor(0xeeeeee);
        return renderer;
    }

    _createControls() {
        const controls = new OrbitControls(this.camera, this.canvas);
        controls.enableDamping = CONTROLS_CONFIG.enableDamping;
        controls.minPolarAngle = CONTROLS_CONFIG.polarAngle.min;
        controls.maxPolarAngle = CONTROLS_CONFIG.polarAngle.max;
        controls.maxDistance = CONTROLS_CONFIG.distance.max;
        controls.minDistance = CONTROLS_CONFIG.distance.min;
        controls.target.set(CONTROLS_CONFIG.target.x, CONTROLS_CONFIG.target.y, CONTROLS_CONFIG.target.z);
        controls.update();
        return controls;
    }

    _updateRendererSize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    animate() {
        requestAnimationFrame(this.animate);
        this.controls.update();
        TWEEN.update();

        this.composer.render();
    }

    _onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.composer.setSize(window.innerWidth, window.innerHeight);
        this.outlinePass.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
    }
    
    dispose() {
        window.removeEventListener('resize', this._onResize);
        this.interactionManager.dispose();
        this.popupManager.dispose();
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/config.js
================
// -- CAMERA & CONTROLS ----------------------------------
export const CAMERA_CONFIG = {
    fov: 75,
    near: 0.1,
    far: 1000,
    position: { x: 30, y: 20, z: 30 },
};

export const CONTROLS_CONFIG = {
    enableDamping: true,
    polarAngle: { min: 0, max: Math.PI / 2 },
    distance: { min: 30, max: 100 },
    target: { x: 0, y: 0, z: 0 },
};

// -- INTERACTION -----------------------------------------
export const PIN_POSITIONS = [
    { x: 10, y: 10, z: 10 },
    { x: -5, y: 10, z: 20 },
];
export const PIN_ASSET_PATH = './assets/pin.png';

// -- MODELS ----------------------------------------------
export const MODEL_DEFINITIONS = {
    'Térreo': { path: './assets/iaud-terreo.glb' },
    '1º Pavimento': { path: './assets/iaud-1opav.glb' },
    'Coberta': { path: './assets/iaud-coberta.glb' },
};

// -- UI & STYLING -----------------------------------------
export const UI_IDS = {
    floorUI: 'floor-ui',
    popup: 'info-popup',
};

export const UI_CLASSES = {
    floorUIContainer: 'floor-ui-container',
    popup: 'info-popup',
    popupCloseButton: 'popup-close',
};

// -- ANIMATION -------------------------------------------
export const ANIMATION_DURATION = 700; // in milliseconds

// -- WORLD -------------------------------------------------
export const GROUND_PLANE_SIZE = 2000.0;

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/InteractionManager.js
================
import * as THREE from 'three';
import { PIN_ASSET_PATH } from './config.js';

export class InteractionManager extends THREE.EventDispatcher {
    constructor(camera, scene, canvas) {
        super();
        this.camera = camera;
        this.scene = scene;
        this.canvas = canvas;

        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();
        this.interactiveObjects = [];

        this._onPointerDown = this._onPointerDown.bind(this);
    }

    init() {
        this.canvas.addEventListener('pointerdown', this._onPointerDown);
    }

    _createPins(pins) {
        const spriteTexture = new THREE.TextureLoader().load(PIN_ASSET_PATH);
        
        pins.forEach(pin => {
            const material = new THREE.SpriteMaterial({ map: spriteTexture, depthTest: true, depthWrite: true,  });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(pin.position);
            sprite.scale.set(2, 2, 1);
            sprite.name = pin.id;
            this.scene.add(sprite);
            this.interactiveObjects.push(sprite);
        });
    }

    _onPointerDown(event) {
        const rect = this.canvas.getBoundingClientRect();
        this.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.pointer, this.camera);
        const intersects = this.raycaster.intersectObjects(this.interactiveObjects);

        if (intersects.length > 0) {
            this.dispatchEvent({ type: 'pinClick', pin: intersects[0].object, event });
        }
    }

    dispose() {
        this.canvas.removeEventListener('pointerdown', this._onPointerDown);
        // Clear interactive objects and remove them from the scene if needed
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/main.js
================
import { App } from './App.js';

document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.querySelector('canvas.webgl');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    const app = new App(canvas);
    app.init();
});

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/ModelManager.js
================
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { MODEL_DEFINITIONS } from './config.js';
import FindSurfaces from './postprocessing/FindSurfaces.js';

export class ModelManager {
    constructor(scene) {
        this.scene = scene;
        this.loader = new GLTFLoader();

        this.models = Object.fromEntries(
            Object.entries(MODEL_DEFINITIONS).map(([key, value]) => [
                value.name || key,
                { path: value.path, object: null, visible: true }
            ])
        );
    }

    sanityCheckMesh(mesh, findSurfaces) {
    const geom = mesh.geometry;
    if (!geom) throw new Error('mesh has no geometry');
    if (!geom.attributes.position) throw new Error('geometry missing position attribute');
    if (!geom.index) throw new Error('geometry missing index buffer');
    const vertexCount = geom.attributes.position.count;

    // generate and validate surface-id attribute
    const surfaceIdAttr = findSurfaces.getSurfaceIdAttribute(mesh);
    if (!(surfaceIdAttr instanceof Float32Array)) throw new Error('surfaceIdAttribute not Float32Array');
    if (surfaceIdAttr.length !== vertexCount * 3) {
        throw new Error(
        `unexpected surfaceId attribute length: got ${surfaceIdAttr.length}, expected ${vertexCount * 4}`
        );
    }

    // quick scan: no NaNs, no infinities, surfaceId (r channel) should be integer-ish
    for (let i = 0; i < surfaceIdAttr.length; i += 3) {
        const r = surfaceIdAttr[i];
        if (!Number.isFinite(r)) throw new Error(`non-finite surfaceId at vertex index ${i / 4}`);
        if (Math.abs(r - Math.round(r)) > 1e-3) {
        console.warn(`surfaceId r channel not near integer at vertex ${i / 3}:`, r);
        }
    }

    return surfaceIdAttr;
    }


    async loadAll() {
    const findSurfaces = new FindSurfaces();
    const loaded = [];
    const failed = [];
    const embeddedPins = [];
    const whitePixel = new Uint8Array([255, 255, 255, 255]); // rgba
    const whiteTexture = new THREE.DataTexture(whitePixel, 1, 1, THREE.RGBAFormat);
    whiteTexture.needsUpdate = true;

    await Promise.all(
        Object.entries(this.models).map(async ([name, modelData]) => {
        try {
            const gltf = await this.loader.loadAsync(modelData.path);
            this.models[name].object = gltf.scene;

            gltf.scene.traverse(child => {
            if (child.isMesh) {
                // make surface-id / outline candidate
                const surfaceIdAttribute = this.sanityCheckMesh(child, findSurfaces);
                child.geometry.setAttribute(
                'color',
                new THREE.BufferAttribute(surfaceIdAttribute, 3)
                );
                child.userData.outlineEligible = true;
                child.layers.enable(1);

                // ====== force white appearance ======
                if (Array.isArray(child.material)) {
                child.material.forEach(mat => applyWhite(mat));
                } else {
                applyWhite(child.material);
                }
            }
              // collect embedded pin points
            if (child.name?.startsWith("Pin_")) {
                const id = child.name.slice(4);
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                embeddedPins.push({ id, position: worldPos });
            }
            });

            // helper
            function applyWhite(mat) {
            if (!mat) return;
            // preserve original type if you want lighting; just override base color / texture
            if ('color' in mat) mat.color.setHex(0xffffff);
            // remove any existing albedo/diffuse maps so they don't modulate
            mat.map = whiteTexture;
            mat.emissive && mat.emissive.setHex(0x000000); // avoid glow
            mat.needsUpdate = true;
}
            this.scene.add(gltf.scene);
            loaded.push(name);
            
            if (embeddedPins.length > 0 && typeof this.onPinsLoaded === 'function') {
            this.onPinsLoaded(embeddedPins);
            }
        } catch (err) {
            console.error(`error loading model "${name}" from ${modelData.path}:`, err);
            failed.push({ name, path: modelData.path, error: err });
        }
        })
    );

    return { loaded, failed };
    }


    setVisibility(floorLevel) {
        Object.entries(this.models).forEach(([name, modelData]) => {
            if (!modelData.object) return;

            let isVisible = false;
            if (floorLevel === 2) {
                isVisible = true; // Show all
            } else if (floorLevel === 1) {
                isVisible = (name !== 'Coberta');
            } else if (floorLevel === 0) {
                isVisible = (name === 'Térreo');
            }
            modelData.object.visible = isVisible;
        });
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/PopupManager.js
================
import TWEEN from 'three/examples/jsm/libs/tween.module.js';
import { UI_IDS, UI_CLASSES, ANIMATION_DURATION } from './config.js';

export class PopupManager {
    constructor(camera, controls, uiManager) {
        this.camera = camera;
        this.controls = controls;
        this.uiManager = uiManager;

        this.savedCameraState = null;
        this._currentPopup = null;
        this._handleOutsideClick = null;
    }

    show(pin, event) {
        if (document.getElementById(UI_IDS.popup)) return;

        this.savedCameraState = {
            position: this.camera.position.clone(),
            target: this.controls.target.clone(),
        };

        const popup = this._createPopupElement(event.clientX, event.clientY);
        this._currentPopup = popup;

        this._animatePopupOpen(popup);
        this._animateCameraToPin(pin);
        this.uiManager.toggleFloorUI(false);

        popup.querySelector(`.${UI_CLASSES.popupCloseButton}`).addEventListener('click', () => this.close());

        this._handleOutsideClick = (e) => {
            if (!popup.contains(e.target)) {
                this.close();
            }
        };
        setTimeout(() => document.addEventListener('pointerdown', this._handleOutsideClick), 0);
    }

    close() {
        const popup = this._currentPopup;
        if (!popup) return;

        if (this._handleOutsideClick) {
            document.removeEventListener('pointerdown', this._handleOutsideClick);
            this._handleOutsideClick = null;
        }

        this._animateCameraToSavedPosition();
        this.uiManager.toggleFloorUI(true);

        popup.style.transform = 'translate(-50%, 150%) scale(0.5)';
        popup.style.opacity = '0';
        
        popup.addEventListener('transitionend', () => {
            popup.remove();
            this._currentPopup = null;
        }, { once: true });
    }

    _createPopupElement(x, y) {
        const popup = document.createElement('div');
        popup.id = UI_IDS.popup;
        popup.className = UI_CLASSES.popup;
        popup.innerHTML = `
            <button class="${UI_CLASSES.popupCloseButton}">&times;</button>
            <div>Environment Preview</div>
            <p>Details about the object at position (${x.toFixed(0)}, ${y.toFixed(0)}) would go here.</p>
        `;
        document.body.appendChild(popup);
        return popup;
    }

    _animatePopupOpen(popup) {
        requestAnimationFrame(() => {
            popup.style.opacity = '1';
            popup.style.transform = 'translateX(-50%)';
        });
    }

    _animateCameraToPin(pin) {
        const offset = this.camera.position.clone().sub(this.controls.target);
        const newTarget = pin.position.clone();
        newTarget.y -= 15;

        const newCamPos = newTarget.clone().add(offset);
        
        new TWEEN.Tween(this.camera.position)
            .to(newCamPos, ANIMATION_DURATION)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onStart(() => {
                this.controls.enabled = false;
            })
            .start();
        
        new TWEEN.Tween(this.controls.target)
            .to(newTarget, ANIMATION_DURATION)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                this.controls.enabled = true;
            })
            .start();
    }

    _animateCameraToSavedPosition() {
        if (!this.savedCameraState) return;

        new TWEEN.Tween(this.camera.position)
            .to(this.savedCameraState.position, ANIMATION_DURATION)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onStart(() => {
                this.controls.enabled = false;
            })
            .start();
            
        new TWEEN.Tween(this.controls.target)
            .to(this.savedCameraState.target, ANIMATION_DURATION)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                this.controls.enabled = true;
            })
            .start();
            
        this.savedCameraState = null;
    }
    
    dispose() {
        if (this._handleOutsideClick) {
            document.removeEventListener('pointerdown', this._handleOutsideClick);
            this._handleOutsideClick = null;
        }
        if (this._currentPopup) {
            this._currentPopup.remove();
            this._currentPopup = null;
        }
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/postprocessing/CustomOutlinePass.js
================
import * as THREE from "three";
import { Pass } from "three/examples/jsm/postprocessing/Pass.js";
import { FullScreenQuad } from "three/examples/jsm/postprocessing/Pass.js";
import {
  getSurfaceIdMaterial,
} from "./FindSurfaces.js";

// Follows the structure of
// 		https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/OutlinePass.js
class CustomOutlinePass extends Pass {
  constructor(resolution, scene, camera) {
    super();

    this.renderScene = scene;
    this.renderCamera = camera;
    this.resolution = new THREE.Vector2(resolution.x, resolution.y);

    this.fsQuad = new FullScreenQuad(null);
    this.fsQuad.material = this.createOutlinePostProcessMaterial();

    // Create a buffer to store the normals of the scene onto
    // or store the "surface IDs"
    const surfaceBuffer = new THREE.WebGLRenderTarget(
      this.resolution.x,
      this.resolution.y
    );
    surfaceBuffer.texture.format = THREE.RGBAFormat;
    surfaceBuffer.texture.type = THREE.HalfFloatType;
    surfaceBuffer.texture.minFilter = THREE.NearestFilter;
    surfaceBuffer.texture.magFilter = THREE.NearestFilter;
    surfaceBuffer.texture.generateMipmaps = false;
    surfaceBuffer.stencilBuffer = false;
    this.surfaceBuffer = surfaceBuffer;

    this.normalOverrideMaterial = new THREE.MeshNormalMaterial();
    this.surfaceIdOverrideMaterial = getSurfaceIdMaterial();
  }

  dispose() {
    this.surfaceBuffer.dispose();
    this.fsQuad.dispose();
  }

  updateMaxSurfaceId(maxSurfaceId) {
    this.surfaceIdOverrideMaterial.uniforms.maxSurfaceId.value = maxSurfaceId;
  }

  setSize(width, height) {
    this.surfaceBuffer.setSize(width, height);
    this.resolution.set(width, height);

    this.fsQuad.material.uniforms.screenSize.value.set(
      this.resolution.x,
      this.resolution.y,
      1 / this.resolution.x,
      1 / this.resolution.y
    );
  }

  render(renderer, writeBuffer, readBuffer) {
    // Turn off writing to the depth buffer
    // because we need to read from it in the subsequent passes.
    const depthBufferValue = writeBuffer.depthBuffer;
    writeBuffer.depthBuffer = false;

    // 1. Re-render the scene to capture all suface IDs in a texture.
    const prevCameraMask = this.renderCamera.layers.mask;
    if (typeof this.outlineLayer === 'number') {
      this.renderCamera.layers.set(this.outlineLayer);
    }

    renderer.setRenderTarget(this.surfaceBuffer);
    const prevOverride = this.renderScene.overrideMaterial;

    this.renderScene.overrideMaterial = this.surfaceIdOverrideMaterial;
    renderer.render(this.renderScene, this.renderCamera);
    this.renderScene.overrideMaterial = prevOverride;

    // restore camera layers
    if (typeof this.outlineLayer === 'number') {
      this.renderCamera.layers.mask = prevCameraMask;
    }

    this.fsQuad.material.uniforms["depthBuffer"].value =
      readBuffer.depthTexture;
    this.fsQuad.material.uniforms["surfaceBuffer"].value =
      this.surfaceBuffer.texture;
    this.fsQuad.material.uniforms["sceneColorBuffer"].value =
      readBuffer.texture;

    // 2. Draw the outlines using the depth texture and normal texture
    // and combine it with the scene color
    if (this.renderToScreen) {
      // If this is the last effect, then renderToScreen is true.
      // So we should render to the screen by setting target null
      // Otherwise, just render into the writeBuffer that the next effect will use as its read buffer.
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      this.fsQuad.render(renderer);
    }

    // Reset the depthBuffer value so we continue writing to it in the next render.
    writeBuffer.depthBuffer = depthBufferValue;
  }

  get vertexShader() {
    return `
			varying vec2 vUv;
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
			`;
  }
  get fragmentShader() {
    return `
			#include <packing>
			// The above include imports "perspectiveDepthToViewZ"
			// and other GLSL functions from ThreeJS we need for reading depth.
			uniform sampler2D sceneColorBuffer;
			uniform sampler2D depthBuffer;
			uniform sampler2D surfaceBuffer;
			uniform float cameraNear;
			uniform float cameraFar;
			uniform vec4 screenSize;
			uniform vec3 outlineColor;
			uniform vec2 multiplierParameters;

			varying vec2 vUv;

			// Helper functions for reading from depth buffer.
			float readDepth (sampler2D depthSampler, vec2 coord) {
				float fragCoordZ = texture2D(depthSampler, coord).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
			}
			float getLinearDepth(vec3 pos) {
				return -(viewMatrix * vec4(pos, 1.0)).z;
			}

			float getLinearScreenDepth(sampler2D map) {
					vec2 uv = gl_FragCoord.xy * screenSize.zw;
					return readDepth(map,uv);
			}
			// Helper functions for reading normals and depth of neighboring pixels.
			float getPixelDepth(int x, int y) {
				// screenSize.zw is pixel size 
				// vUv is current position
				return readDepth(depthBuffer, vUv + screenSize.zw * vec2(x, y));
			}
			// "surface value" is either the normal or the "surfaceID"
			vec3 getSurfaceValue(int x, int y) {
				vec3 val = texture2D(surfaceBuffer, vUv + screenSize.zw * vec2(x, y)).rgb;
				return val;
			}

			float saturateValue(float num) {
				return clamp(num, 0.0, 1.0);
			}

			float getSufaceIdDiff(vec3 surfaceValue) {
				float surfaceIdDiff = 0.0;
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(1, 0));
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(0, 1));
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(0, 1));
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(0, -1));

				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(1, 1));
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(1, -1));
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(-1, 1));
				surfaceIdDiff += distance(surfaceValue, getSurfaceValue(-1, -1));
				return surfaceIdDiff;
			}

			void main() {
				vec4 sceneColor = texture2D(sceneColorBuffer, vUv);
				float depth = getPixelDepth(0, 0);
				vec3 surfaceValue = getSurfaceValue(0, 0);

				// Get the difference between depth of neighboring pixels and current.
				float depthDiff = 0.0;
				depthDiff += abs(depth - getPixelDepth(1, 0));
				depthDiff += abs(depth - getPixelDepth(-1, 0));
				depthDiff += abs(depth - getPixelDepth(0, 1));
				depthDiff += abs(depth - getPixelDepth(0, -1));

				// Get the difference between surface values of neighboring pixels
				// and current
				float surfaceValueDiff = getSufaceIdDiff(surfaceValue);
				
				// Apply multiplier & bias to each 
				float depthBias = multiplierParameters.x;
				float depthMultiplier = multiplierParameters.y;

				depthDiff = depthDiff * depthMultiplier;
				depthDiff = saturateValue(depthDiff);
				depthDiff = pow(depthDiff, depthBias);

				if (surfaceValueDiff != 0.0) surfaceValueDiff = 1.0;

				float outline = saturateValue(surfaceValueDiff + depthDiff);
			
				// Combine outline with scene color.
				vec4 outlineColor = vec4(outlineColor, 1.0);
				gl_FragColor = vec4(mix(sceneColor, outlineColor, outline));
			}
			`;
  }

  createOutlinePostProcessMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        sceneColorBuffer: {},
        depthBuffer: {},
        surfaceBuffer: {},
        outlineColor: { value: new THREE.Color(0x000000) },
        //4 scalar values packed in one uniform:
        //  depth multiplier, depth bias
        multiplierParameters: {
          value: new THREE.Vector2(0.9, 20),
        },
        cameraNear: { value: this.renderCamera.near },
        cameraFar: { value: this.renderCamera.far },
        screenSize: {
          value: new THREE.Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          ),
        },
      },
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader,
    });
  }
}

export { CustomOutlinePass };

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/postprocessing/FindSurfaces.js
================
import * as THREE from "three";

/*
  This class computes "surface IDs" for a given mesh.

  A "surface" is defined as a set of triangles that share vertices.
 
  Inspired by Ian MacLarty, see:
    https://twitter.com/ianmaclarty/status/1499494878908403712
*/
class FindSurfaces {
  constructor() {
    // This identifier, must be globally unique for each surface
    // across all geometry rendered on screen
    this.surfaceId = 0;
  }

  /*
   * Returns the surface Ids as a Float32Array that can be inserted as a vertex attribute
   */
  getSurfaceIdAttribute(mesh) {
    const bufferGeometry = mesh.geometry;
    const numVertices = bufferGeometry.attributes.position.count;
    const vertexIdToSurfaceId = this._generateSurfaceIds(mesh);

    const colors = [];
    for (let i = 0; i < numVertices; i++) {
      const vertexId = i;
      let surfaceId = vertexIdToSurfaceId[vertexId];

      colors.push(surfaceId, 0, 0);
    }

    const colorsTypedArray = new Float32Array(colors);
    return colorsTypedArray;
  }

  /*
   * Returns a `vertexIdToSurfaceId` map
   * given a vertex, returns the surfaceId
   */
  _generateSurfaceIds(mesh) {
    const bufferGeometry = mesh.geometry;
    const numVertices = bufferGeometry.attributes.position.count;
    const numIndices = bufferGeometry.index.count;
    const indexBuffer = bufferGeometry.index.array;
    const vertexBuffer = bufferGeometry.attributes.position.array;
    // For each vertex, search all its neighbors
    const vertexMap = {};
    for (let i = 0; i < numIndices; i += 3) {
      const i1 = indexBuffer[i + 0];
      const i2 = indexBuffer[i + 1];
      const i3 = indexBuffer[i + 2];

      add(i1, i2);
      add(i1, i3);
      add(i2, i3);
    }
    function add(a, b) {
      if (vertexMap[a] == undefined) vertexMap[a] = [];
      if (vertexMap[b] == undefined) vertexMap[b] = [];

      if (vertexMap[a].indexOf(b) == -1) vertexMap[a].push(b);
      if (vertexMap[b].indexOf(a) == -1) vertexMap[b].push(a);
    }

    // Find cycles
    const frontierNodes = Object.keys(vertexMap).map((v) => Number(v));
    const exploredNodes = {};
    const vertexIdToSurfaceId = {};

    while (frontierNodes.length > 0) {
      const node = frontierNodes.pop();
      if (exploredNodes[node]) continue;

      // Get all neighbors recursively
      const surfaceVertices = getNeighborsNonRecursive(node);
      // Mark them as explored
      for (let v of surfaceVertices) {
        exploredNodes[v] = true;
        vertexIdToSurfaceId[v] = this.surfaceId;
      }

      this.surfaceId += 1;
    }
    function getNeighbors(node, explored) {
      const neighbors = vertexMap[node];
      let result = [node];
      explored[node] = true;

      for (let n of neighbors) {
        if (explored[n]) continue;
        explored[n] = true;
        const newNeighbors = getNeighbors(n, explored);
        result = result.concat(newNeighbors);
      }

      return result;
    }

    function getNeighborsNonRecursive(node) {
      const frontier = [node];
      const explored = {};
      const result = [];

      while (frontier.length > 0) {
        const currentNode = frontier.pop();
        if (explored[currentNode]) continue;
        const neighbors = vertexMap[currentNode];
        result.push(currentNode);

        explored[currentNode] = true;

        for (let n of neighbors) {
          if (!explored[n]) {
            frontier.push(n);
          }
        }
      }

      return result;
    }

    return vertexIdToSurfaceId;
  }
}

export default FindSurfaces;

export function getSurfaceIdMaterial() {
  return new THREE.ShaderMaterial({
    uniforms: {
      maxSurfaceId: { value: 1 },
    },
    vertexShader: getVertexShader(),
    fragmentShader: getFragmentShader(),
    vertexColors: true,
  });
}

// vertex shader
function getVertexShader() {
  return `
  varying vec2 v_uv;
  varying vec3 vColor;

  void main() {
    v_uv = uv;
    vColor = color; // vec3 -> vec3 ok
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
  `;
}

// fragment shader
function getFragmentShader() {
  return `
  varying vec2 v_uv;
  varying vec3 vColor;
  uniform float maxSurfaceId;

  void main() {
    float surfaceId = round(vColor.r) / maxSurfaceId;
    gl_FragColor = vec4(surfaceId, 0.0, 0.0, 1.0);
  }
  `;
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/UIManager.js
================
import { UI_IDS, UI_CLASSES } from './config.js';

export class UIManager {
    constructor() {
        this.floorUIContainer = null;
    }

    createFloorUI(modelManager) {
        const uiContainer = document.createElement('div');
        uiContainer.id = UI_IDS.floorUI;
        uiContainer.className = UI_CLASSES.floorUIContainer;

        const floorActions = [
            { label: '2', level: 2 },
            { label: '1', level: 1 },
            { label: '0', level: 0 }
        ];

        floorActions.forEach(({ label, level }) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.onclick = () => modelManager.setVisibility(level);
            uiContainer.appendChild(btn);
        });

        document.body.appendChild(uiContainer);
        this.floorUIContainer = uiContainer;
    }

    toggleFloorUI(show) {
        if (this.floorUIContainer) {
            this.floorUIContainer.style.opacity = show ? '1' : '0.1';
            this.floorUIContainer.style.pointerEvents = show ? 'auto' : 'none';
        }
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/World.js
================
import * as THREE from 'three';
import { GROUND_PLANE_SIZE } from './config.js';

// --- Shaders ---
const groundVertexShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const groundFragmentShader = `
    varying vec2 vUv;
    uniform vec3 colorCenter;
    uniform vec3 colorEdge;
    void main() {
        float dist = distance(vUv, vec2(0.5));
        float t = smoothstep(0.0, 0.15, dist);
        vec3 color = mix(colorCenter, colorEdge, t);
        gl_FragColor = vec4(color, 1.0);
    }
`;

export class World {
    constructor(scene) {
        this.scene = scene;
    }

    setup() {
        this._createLights();
        this._createGround();
    }

    _createLights() {
        const ambientLight = new THREE.AmbientLight(0xfff9f3, 1.2);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(15, 10, -5);
        this.scene.add(directionalLight);
    }

    _createGround() {
        const planeGeometry = new THREE.PlaneGeometry(GROUND_PLANE_SIZE, GROUND_PLANE_SIZE);
        const planeMaterial = new THREE.ShaderMaterial({
            vertexShader: groundVertexShader,
            fragmentShader: groundFragmentShader,
            uniforms: {
                colorCenter: { value: new THREE.Color(0xfbfbfb) },
                colorEdge: { value: new THREE.Color(0xbdbdbd) }
            },
        });
        const ground = new THREE.Mesh(planeGeometry, planeMaterial);
        ground.rotation.x = -Math.PI / 2;
        this.scene.add(ground);
    }
}
