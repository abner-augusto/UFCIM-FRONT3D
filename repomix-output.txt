This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-02T18:21:51.774Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/App.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/InteractionManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/main.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/ModelManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/UIManager.js
D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/World.js

================================================================
Repository Files
================================================================

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/App.js
================
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import TWEEN from 'three/examples/jsm/libs/tween.module.js';

import { World } from './World.js';
import { ModelManager } from './ModelManager.js';
import { UIManager } from './UIManager.js';
import { InteractionManager } from './InteractionManager.js';

export class App {
    constructor(canvas) {
        this.canvas = canvas;

        // Core Three.js components
        this.scene = new THREE.Scene();
        this.camera = this._createCamera();
        this.renderer = this._createRenderer();
        this.controls = this._createControls();

        // App components
        this.world = new World(this.scene);
        this.modelManager = new ModelManager(this.scene);
        this.uiManager = new UIManager();
        this.interactionManager = new InteractionManager(this.camera, this.scene, this.canvas);

        // Bind 'this' to methods that are used as callbacks
        this.animate = this.animate.bind(this);
        this._onResize = this._onResize.bind(this);
    }

    async init() {
        this.world.setup();
        
        // Listen for pin clicks from the interaction manager
        this.interactionManager.addEventListener('pinClick', (e) => {
            this.uiManager.showPopup(e.pin, e.event, this.camera, this.controls);
        });
        
        this.interactionManager.init();

        try {
            await this.modelManager.loadAll();
            this.uiManager.createFloorUI(this.modelManager);
        } catch (error) {
            console.error("Failed to load models:", error);
        }

        window.addEventListener('resize', this._onResize);
        this.animate();
    }
    
    _createCamera() {
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 20, 30);
        this.scene.add(camera);
        return camera;
    }

    _createRenderer() {
        const renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0xeeeeee);
        return renderer;
    }

    _createControls() {
        const controls = new OrbitControls(this.camera, this.canvas);
        controls.enableDamping = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI / 2;
        controls.maxDistance = 100;
        controls.minDistance = 30;
        controls.target.set(0, 0, 0);
        controls.update();
        return controls;
    }

    animate() {
        requestAnimationFrame(this.animate);
        this.controls.update();
        TWEEN.update();
        this.renderer.render(this.scene, this.camera);
    }

    _onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/InteractionManager.js
================
import * as THREE from 'three';

export class InteractionManager extends THREE.EventDispatcher {
    constructor(camera, scene, canvas) {
        super();
        this.camera = camera;
        this.scene = scene;
        this.canvas = canvas;
        
        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();
        this.interactiveObjects = [];
        
        this._onPointerDown = this._onPointerDown.bind(this);
    }
    
    init() {
        this._createPins();
        this.canvas.addEventListener('pointerdown', this._onPointerDown);
    }

    _createPins() {
        const spriteTexture = new THREE.TextureLoader().load('./assets/pin.png');
        const pinPositions = [
            new THREE.Vector3(10, 10, 10),
            new THREE.Vector3(-5, 10, 20),
        ];

        pinPositions.forEach(pos => {
            const spriteMaterial = new THREE.SpriteMaterial({ map: spriteTexture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(pos);
            sprite.scale.set(2, 2, 1); // Make pin a bit larger
            this.scene.add(sprite);
            this.interactiveObjects.push(sprite);
        });
    }

    _onPointerDown(event) {
        const rect = this.canvas.getBoundingClientRect();
        this.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.pointer, this.camera);
        const intersects = this.raycaster.intersectObjects(this.interactiveObjects);

        if (intersects.length > 0) {
            this.dispatchEvent({ type: 'pinClick', pin: intersects[0].object, event });
        }
    }

    dispose() {
        this.canvas.removeEventListener('pointerdown', this._onPointerDown);
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/main.js
================
import { App } from './App.js';

document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.querySelector('canvas.webgl');
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    const app = new App(canvas);
    app.init();
});

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/ModelManager.js
================
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

export class ModelManager {
    constructor(scene) {
        this.scene = scene;
        this.loader = new GLTFLoader();
        this.models = {
            'Térreo': { path: './assets/iaud-terreo.glb', object: null, visible: true },
            '1º Pavimento': { path: './assets/iaud-1opav.glb', object: null, visible: true },
            'Coberta': { path: './assets/iaud-coberta.glb', object: null, visible: true },
        };
    }

    async loadAll() {
        const loadPromises = Object.entries(this.models).map(([name, modelData]) => {
            return this.loader.loadAsync(modelData.path).then(gltf => {
                this.models[name].object = gltf.scene;
                this.scene.add(gltf.scene);
            });
        });
        return Promise.all(loadPromises);
    }

    setVisibility(floorLevel) {
        Object.entries(this.models).forEach(([name, modelData]) => {
            if (!modelData.object) return;
            
            let isVisible = false;
            if (floorLevel === 2) {
                isVisible = true; // Show all
            } else if (floorLevel === 1) {
                isVisible = (name !== 'Coberta');
            } else if (floorLevel === 0) {
                isVisible = (name === 'Térreo');
            }
            modelData.object.visible = isVisible;
        });
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/UIManager.js
================
import TWEEN from 'three/examples/jsm/libs/tween.module.js';

export class UIManager {
    constructor() {
        this.floorUIName = 'floor-ui';
        this.popupName = 'info-popup';
        this.savedCameraState = null;
    }

    createFloorUI(modelManager) {
        const uiContainer = document.createElement('div');
        uiContainer.id = this.floorUIName;
        Object.assign(uiContainer.style, {
            position: 'absolute', top: '50%', right: '20px', transform: 'translateY(-50%)',
            display: 'flex', flexDirection: 'column', gap: '8px', background: 'rgba(255,255,255,0.8)',
            padding: '10px', borderRadius: '4px', zIndex: '10', transition: 'opacity 0.3s ease'
        });

        const floorActions = [
            { label: '2', level: 2 },
            { label: '1', level: 1 },
            { label: '0', level: 0 }
        ];

        floorActions.forEach(({ label, level }) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.onclick = () => modelManager.setVisibility(level);
            uiContainer.appendChild(btn);
        });
        document.body.appendChild(uiContainer);
    }

    showPopup(pin, event, camera, controls) {
        if (document.getElementById(this.popupName)) return;

        this.savedCameraState = {
            position: camera.position.clone(),
            target: controls.target.clone()
        };

        const popup = this._createPopupElement(event.clientX, event.clientY);
        this._currentPopup = popup;

        this._animatePopupOpen(popup);
        this._animateCameraToPin(pin, camera, controls);
        this._toggleFloorUI(false);

        // Close via button
        popup.querySelector('.popup-close').addEventListener('click', () => this.closePopup(camera, controls));

        // Close via outside click
        this._handleOutsideClick = (e) => {
            if (!popup.contains(e.target)) {
                this.closePopup(camera, controls);
                document.removeEventListener('pointerdown', this._handleOutsideClick);
            }
        };
        setTimeout(() => document.addEventListener('pointerdown', this._handleOutsideClick), 0);
    }


    closePopup(camera, controls) {
        const popup = document.getElementById(this.popupName);
        if (!popup) return;

        popup.style.transform = 'translate(-50%, 150%) scale(0.5)';
        popup.style.opacity = '0';
        popup.addEventListener('transitionend', () => popup.remove(), { once: true });

        this._animateCameraToSavedPosition(camera, controls);
        this._toggleFloorUI(true);

        // Remove outside click listener and popup reference
        if (this._handleOutsideClick) {
            document.removeEventListener('pointerdown', this._handleOutsideClick);
            this._handleOutsideClick = null;
        }
        this._currentPopup = null;
    }

    
    _createPopupElement(x, y) {
        const popup = document.createElement('div');
        popup.id = this.popupName;
        popup.innerHTML = `
            <button class="popup-close" style="position:absolute;top:5px;right:5px;background:none;border:none;font-size:18px;cursor:pointer;">&times;</button>
            <div>Environment Preview</div>
            <p>Details about the object at position (${x.toFixed(0)}, ${y.toFixed(0)}) would go here.</p>
        `;
        Object.assign(popup.style, {
            position: 'absolute', left: '50%', bottom: '20px', transform: 'translateX(-50%)',
            width: '80%', height: '50vh', padding: '20px', background: '#fff',
            border: '1px solid #ccc', boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
            borderRadius: '8px', zIndex: '20', opacity: '0',
            transition: 'opacity 0.3s ease, transform 0.4s ease-out'
        });
        document.body.appendChild(popup);
        return popup;
    }

    _animatePopupOpen(popup) {
        requestAnimationFrame(() => {
            popup.style.opacity = '1';
            popup.style.transform = 'translateX(-50%)';
        });
    }
    
    _animateCameraToPin(pin, camera, controls) {
        const offset = camera.position.clone().sub(controls.target);
        const newTarget = pin.position.clone();

        const verticalOffset = 15; 
        newTarget.y -= verticalOffset;

        const newCamPos = newTarget.clone().add(offset);
        
        new TWEEN.Tween(camera.position)
            .to(newCamPos, 1000)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();
            
        new TWEEN.Tween(controls.target)
            .to(newTarget, 1000)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();
    }
        
    _animateCameraToSavedPosition(camera, controls) {
        if (!this.savedCameraState) return;
        new TWEEN.Tween(camera.position).to(this.savedCameraState.position, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        new TWEEN.Tween(controls.target).to(this.savedCameraState.target, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        this.savedCameraState = null;
    }
    
    _toggleFloorUI(show) {
        const floorMenu = document.getElementById(this.floorUIName);
        if (floorMenu) {
            floorMenu.style.opacity = show ? '1' : '0.1';
            floorMenu.style.pointerEvents = show ? 'auto' : 'none';
        }
    }
}

================
File: D:/Nextcloud/1-ABNER/APP IAUD/UFCIM-FRONT3D/src/World.js
================
import * as THREE from 'three';

export class World {
    constructor(scene) {
        this.scene = scene;
    }

    setup() {
        this._createLights();
        this._createGround();
    }

    _createLights() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(-5, 3, 10);
        this.scene.add(directionalLight);
    }

    _createGround() {
        const planeSize = 2000.0;
        const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
        const planeMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform vec3 colorCenter;
                uniform vec3 colorEdge;
                void main() {
                    float dist = distance(vUv, vec2(0.5));
                    float t = smoothstep(0.0, 0.5, dist);
                    vec3 color = mix(colorCenter, colorEdge, t);
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            uniforms: {
                colorCenter: { value: new THREE.Color(0xfbfbfb) },
                colorEdge: { value: new THREE.Color(0xf0f0f0) }
            },
        });

        const ground = new THREE.Mesh(planeGeometry, planeMaterial);
        ground.rotation.x = -Math.PI / 2;
        this.scene.add(ground);
    }
}
